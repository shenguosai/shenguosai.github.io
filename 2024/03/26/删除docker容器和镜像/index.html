<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>删除 docker 容器和镜像 | 小人驿站</title><meta name="author" content="市井一俗人"><meta name="copyright" content="市井一俗人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是 Docker? Docker是基于Go语言实现的在 2013 年发布的云开源项目，它利用了围绕容器这个现有的计算概念，特别是在Linux世界中，这些原始概念被称为cgroups和命名空间。Docker的技术之所以独特是因为它专注于开发人员和系统操作员的需求，以将应用程序依赖项与基础架构分开。 Docker的主要目标是 “Build，Ship and Run Any App,Anywhere">
<meta property="og:type" content="article">
<meta property="og:title" content="删除 docker 容器和镜像">
<meta property="og:url" content="https://shenguosai.github.io/2024/03/26/%E5%88%A0%E9%99%A4docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F/index.html">
<meta property="og:site_name" content="小人驿站">
<meta property="og:description" content="什么是 Docker? Docker是基于Go语言实现的在 2013 年发布的云开源项目，它利用了围绕容器这个现有的计算概念，特别是在Linux世界中，这些原始概念被称为cgroups和命名空间。Docker的技术之所以独特是因为它专注于开发人员和系统操作员的需求，以将应用程序依赖项与基础架构分开。 Docker的主要目标是 “Build，Ship and Run Any App,Anywhere">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shenguosai.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-03-26T14:10:34.000Z">
<meta property="article:modified_time" content="2025-04-16T15:34:47.421Z">
<meta property="article:author" content="市井一俗人">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shenguosai.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "删除 docker 容器和镜像",
  "url": "https://shenguosai.github.io/2024/03/26/%E5%88%A0%E9%99%A4docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F/",
  "image": "https://shenguosai.github.io/img/butterfly-icon.png",
  "datePublished": "2024-03-26T14:10:34.000Z",
  "dateModified": "2025-04-16T15:34:47.421Z",
  "author": [
    {
      "@type": "Person",
      "name": "市井一俗人",
      "url": "https://shenguosai.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://shenguosai.github.io/2024/03/26/%E5%88%A0%E9%99%A4docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '删除 docker 容器和镜像',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="小人驿站" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小人驿站</span></a><a class="nav-page-title" href="/"><span class="site-name">删除 docker 容器和镜像</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">删除 docker 容器和镜像</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-26T14:10:34.000Z" title="发表于 2024-03-26 22:10:34">2024-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-16T15:34:47.421Z" title="更新于 2025-04-16 23:34:47">2025-04-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%85%B4%E8%B6%A3/">技术兴趣</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%85%B4%E8%B6%A3/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/">软件应用</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>什么是 Docker?</h1>
<p><code>Docker</code>是基于 <code>Go 语言</code> 实现的在 2013 年发布的云开源项目，它利用了围绕容器这个现有的计算概念，特别是在 <code>Linux</code> 世界中，这些原始概念被称为 <code>cgroups</code> 和命名空间。<code>Docker</code>的技术之所以独特是因为它专注于开发人员和系统操作员的需求，以将应用程序依赖项与基础架构分开。<br>
<code>Docker</code>的主要目标是 “Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP (可以是一个 WEB 应用或数据库应用等等) 及其运行环境能够做到“一次封装，到处运行”。<br>
一句话概括，<code>Docker</code>的出现解决了运行环境和配置环境不一致的情况，从而更方便的做持续集成并有助于应用的整体发布。</p>
<span id="more"></span>
<h1>Docker 三要素: 镜像、容器和仓库</h1>
<h2 id="镜像">镜像</h2>
<p>在了解镜像这个概念之前，我们需要先大致了解一下联合文件系统:<code>UnionFS</code>，它是 <code>Docker</code> 镜像的基础，联合文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层一层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，镜像可以通过分层来进行集成，我们可以基于一个基础的镜像，然后制作出各种各样满足我们需求的应用镜像。<br>
同时，对于一个精简的 <code>OS</code>，<code>rootfs</code> 可以很小，有常见的命令就行，同时，底层又是直接使用的操作系统的内核，所以往往 <code>Docker</code> 中一个镜像的体积相对来说可以很小，比如一个完整版的 <code>centos</code> 可能要几个 G，但是 <code>Docker</code> 中的 <code>centos</code> 大概只有 300M.<br>
对于 docker 镜像，官方的定义如下:</p>
<blockquote>
<p>An image is a read-only template with instructions for creating a Docker container. Often, an image is based on another image, with some additional customization. For example, you may build an image which is based on the ubuntu image, but installs the Apache web server and your application, as well as the configuration details needed to make your application run.‘<br>
映像是一个只读模板，带有创建 Docker 容器的指令。通常，一个映像是基于另一个映像的，还需要进行一些额外的定制。例如，您可以构建一个基于 ubuntu 映像的映像，但是安装 <code>Apache web</code> 服务器和您的应用程序，以及使您的应用程序运行所需的配置细节。</p>
</blockquote>
<p>PS: <strong><font color="red">一个镜像可以创建多个容器</font></strong>。</p>
<h2 id="容器">容器</h2>
<p>容器是用镜像创建的运行实例。<br>
每个容器都可以被启动，开始，停止，删除，同时容器之间相互隔离，保证应用运行期间的安全。<br>
我们可以把容器理解为一个精简版的 <code>linux</code> 操作系统，包括 <code>root</code> 用户权限，进程空间，用户空间和网络空间等等这些，然后加上再它之上运行的应用程序。<br>
比如我们现在基于 <code>mysql</code> 镜像创建了一个容器，那么，这个容器其实并不是只有一个 <code>mysql</code> 程序，而是 <code>mysql</code> 同样也是安装运行在我们容器内的 <code>linux</code> 环境中的。</p>
<h2 id="容器和镜像的关系">容器和镜像的关系</h2>
<p>再说这个问题之前，我们不妨先来看一下下面这段 <code>java</code> 代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure>
<p>镜像在这里就是我们的 Person，容器就是一个个 Person 类的实例。一个 Person 可以创建多个实例，一个镜像也可以创建多个容器。</p>
<h2 id="仓库">仓库</h2>
<p>仓库相对来说就比较容易理解了，仓库 (Repository) 是集中存放镜像文件的场所。<br>
仓库分为公开仓库和私有仓库，目前的话，全世界最大的仓库是 Docker 官方的 Docker Hub<br>
由于一些不可抗拒的因素，导致我们如果从 Docker Hub 上下载公开的镜像是非常蛋疼的，这点大家可以参考你用百度网盘官方下载时的感觉。所以，国内我们一般使用阿里云或者网易云的镜像仓库。<br>
镜像 容器 仓库 他们三者之间的关系图如下:<br>
<img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326223417.png" alt="20240326223417"></p>
<h1>Docker 容器的创建、启动</h1>
<p>docker 容器的启动有三种方式:</p>
<h2 id="交互方式 - 基于镜像新建容器并启动">交互方式: 基于镜像新建容器并启动</h2>
<p>例如我们可以启动一个容器，打印出当前的日历表:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run my/python:v1 cal   <span class="hljs-comment">## my/python:v1 为镜像名和标签</span><br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326223332.png" alt="20240326223332"><br>
我们还可以通过制定参数，启动一个 bash 交互终端:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it my/python:v1 /bin/bash<br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326223619.png" alt="20240326223619"><br>
参数 <code>-t</code> 让 Docker 分配一个伪终端并绑定在容器的标准输入上，<code>-i</code>让容器的标准输入保持打开。</p>
<p>使用 <code>docker run</code> 命令来启动容器，docker 在后台运行的标准操作包括<br>
1. 检查本地是否存在指定的镜像，不存在则从公有仓库下载;<br>
2. 使用镜像创建并启动容器;<br>
3. 分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层;<br>
4. 从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去;<br>
5. 从地址池分配一个 ip 地址给容器;<br>
6. 执行用户指定的应用程序;<br>
7. 执行完毕之后容器被终止。<br>
<img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326223751.png" alt="20240326223751"><br>
<code>my/sinatra:v2</code>基于 <code>training/sinatra</code> 镜像进行修改后的镜像，<code>training/sinatra</code>为公有仓库上的镜像。</p>
<h2 id="短暂方式 - 直接将一个已经终止的容器启动运行起来">短暂方式: 直接将一个已经终止的容器启动运行起来</h2>
<p>可以使用 <code>docker start</code> 命令，直接将一个已经终止的容器启动运行起来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@rocketmq-nameserver4 ~]# docker run my/python:v1 /bin/echo hello <span class="hljs-built_in">test</span><br>hello <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>
<p>命令执行完，控制台会打印<code>hello test</code>，container 就终止了，不过并没有消失，<br>
可以用 <code>docker ps -n 5</code> 看一下最新前 5 个的 container，第一个就是刚刚执行过的 container，可以再次执行一遍：<code>docker start container_id</code><br>
不过这次控制台看不到 <code>hello test</code> 了，只能看到 ID，用 <code>logs</code> 命令才能看得到：<code>docker logs container_id</code>。<br>
可以看到两个 <code>hello test</code> 了，因为这个 container 运行了两次。<br>
<img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326224054.png" alt="20240326224054"></p>
<h2 id="Daemen- 方式 - 守护态运行">Daemen 方式(守护态运行)</h2>
<p>即让软件作为长时间服务运行，这就是 SAAS 啊！<br>
例如我们启动 centos 后台容器，每隔一秒打印当天的日历。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d centos /bin/sh -c <span class="hljs-string">&quot;while true;do echo hello docker;sleep 1;done&quot;</span><br></code></pre></td></tr></table></figure>
<p>启动之后，我们使用 <code>docker ps -n 5</code> 查看容器的信息</p>
<p>要查看启动的 centos 容器中的输出，可以使用如下方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs <span class="hljs-variable">$CONTAINER_ID</span>   <span class="hljs-comment">## 在 container 外面查看它的输出</span><br>$ docker attach <span class="hljs-variable">$CONTAINER_ID</span>   <span class="hljs-comment">## 连接上容器实时查看</span><br></code></pre></td></tr></table></figure>
<h1>Docker 容器的终止</h1>
<p>使用以下命令来终止一个运行中的容器。并且可以使用 <code>docker ps -a</code> 来看终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop <span class="hljs-variable">$CONTAINER_ID</span><br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326224511.png" alt="20240326224511"><br>
终止状态的容器，可以使用 <code>docker start</code> 来重新启动。<br>
<img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326224547.png" alt="20240326224547"><br>
使用 docker restart 命令来重启一个容器。<br>
<img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326224612.png" alt="20240326224612"></p>
<h1>删除 Docker 容器</h1>
<p>如果容器还在运行，将无法删除镜像，所以从删除容器开始。</p>
<ul>
<li>查看 Docker 所有容器状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a<br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326225006.png" alt="20240326225006"></p>
<ul>
<li>停止容器运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop <span class="hljs-variable">$CONTAINER_ID</span><br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326225218.png" alt="20240326225218"></p>
<ul>
<li>删除容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> <span class="hljs-variable">$CONTAINER_ID</span><br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326225338.png" alt="20240326225338"></p>
<h1>删除 Docker 镜像</h1>
<ul>
<li>查看 docker 要删除的镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326225523.png" alt="20240326225523"></p>
<ul>
<li>由于刚才已终止此镜像的容器，所以直接删除</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi <span class="hljs-variable">$IMAGE_ID</span><br></code></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shenguosai/MyPic/img/img/20240326225653.png" alt="20240326225653"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://shenguosai.github.io">市井一俗人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://shenguosai.github.io/2024/03/26/%E5%88%A0%E9%99%A4docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F/">https://shenguosai.github.io/2024/03/26/%E5%88%A0%E9%99%A4docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://shenguosai.github.io" target="_blank">小人驿站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/03/27/%E3%80%90%E8%BD%AC%E3%80%91%E8%B6%8A%E7%8B%B1%E5%90%8E%E7%8E%A9%E8%80%8DIPhone%E7%B3%BB%E7%BB%9F(Darwin)/" title="【转】越狱后玩耍 IPhone 系统 (Darwin)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【转】越狱后玩耍 IPhone 系统 (Darwin)</div></div><div class="info-2"><div class="info-item-1">无意中找到一个介绍越狱后 iOS 的说明， 受益匪浅， 转一下:【Darwin】 越狱后玩耍 IPhone 系统  大家都知道 iOS 是自 Mac OS 修改而来的。而 Mac OS 和 iOS 的共同核心是 Darwin, 其基于 FreeBSD 发展而来, 整体而言也是个类 Unix 系统。之前把自己的手机越狱之后正好开始接触 Linux 这类 OS， 然后觉得很有意思就去网上找了些资料来自己玩自己的手机， 也做了一些笔记。说来惭愧， 当时手机系统版本还是 8.3。而后来也因为没什么时间加上这部分笔记维护在另外一个笔记本上， 导致一直没有时间记录下来【捂脸】。本来想等 10.3 的越狱出来， 把 Pad 越狱之后再来详细研究的， 无奈 10.3 越狱也迟迟不出， 不得已， 只好现在来记录一下了。。 没有什么干货的技术知识， 全部都是一点个人的爱折腾手机的小兴趣， 系统版本又老。。嗯就这样吧。 第一步 IPhone 越狱后， 第一标志当然就是在桌面上看到了 Cydia。作为折腾手机的第一步， 当然是要让手机有本地命令行来装逼了。如果没记错的话， 几年前越狱的时候还是会附带一个...</div></div></div></a><a class="pagination-related" href="/2024/03/26/Windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9C%A8cmd%E4%B8%AD%E8%83%BD%E6%89%A7%E8%A1%8C%E4%BD%86%E6%98%AF%E5%9C%A8PowerShell%E4%B8%AD%E6%8A%A5%E9%94%99/" title="Windows 命令行在 cmd 中能执行但是在 PowerShell 中报错"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Windows 命令行在 cmd 中能执行但是在 PowerShell 中报错</div></div><div class="info-2"><div class="info-item-1">使用 ssh 远程 windows 端的时候默认使用 cmd，而用 powershell 可以使用很多 linux 的命令，像 ls，ps，cd 什么的(实际上只是映射了一下)。 使用管理员权限在 PowerShell 执行以下命令，使 SSH 连接 Windows 时默认使用Powershell。 1New-ItemProperty -Path &quot;HKLM:\SOFTWARE\OpenSSH&quot; -Name DefaultShell -Value &quot;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -PropertyType String -Force  但是今天远程 Windows 下开启 http-server 服务时却遇到一个奇怪的问题。  这个问题也可以描述为: powershell 中无法执行命令 / 脚本   尝试了一下发现一部分命令是可以执行的，就考虑是不是权限相关的问题，通过多方查证，总结了以下解决办法:  运行命令行查看系统权限:  1Get-Execut...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">市井一俗人</div><div class="author-info-description">怀出世之心，行入世之事。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">什么是 Docker?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Docker 三要素: 镜像、容器和仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F"><span class="toc-number">2.1.</span> <span class="toc-text">镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">容器和镜像的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%93%E5%BA%93"><span class="toc-number">2.4.</span> <span class="toc-text">仓库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Docker 容器的创建、启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F%20-%20%E5%9F%BA%E4%BA%8E%E9%95%9C%E5%83%8F%E6%96%B0%E5%BB%BA%E5%AE%B9%E5%99%A8%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="toc-number">3.1.</span> <span class="toc-text">交互方式: 基于镜像新建容器并启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E6%9A%82%E6%96%B9%E5%BC%8F%20-%20%E7%9B%B4%E6%8E%A5%E5%B0%86%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%BB%8F%E7%BB%88%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5"><span class="toc-number">3.2.</span> <span class="toc-text">短暂方式: 直接将一个已经终止的容器启动运行起来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Daemen-%20%E6%96%B9%E5%BC%8F%20-%20%E5%AE%88%E6%8A%A4%E6%80%81%E8%BF%90%E8%A1%8C"><span class="toc-number">3.3.</span> <span class="toc-text">Daemen 方式(守护态运行)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Docker 容器的终止</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">删除 Docker 容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">删除 Docker 镜像</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/24/%E5%88%9D%E4%B8%AD%E6%95%B0%E5%AD%A6%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95%E5%8F%8A%E6%A8%A1%E5%9E%8B/" title="初中数学解题方法及模型">初中数学解题方法及模型</a><time datetime="2025-11-24T07:31:40.000Z" title="发表于 2025-11-24 15:31:40">2025-11-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/06/Hexo%E4%BB%8Egithub%E5%85%8B%E9%9A%86%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%9A%84%E4%B8%BB%E9%A2%98%E5%BA%93%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%87%AA%E5%B7%B1%E4%BB%93%E5%BA%93%E7%9A%84thems%E6%96%87%E4%BB%B6%E5%A4%B9/" title="Hexo 从 github 克隆到本地的主题库无法上传到自己仓库的 thems 文件夹">Hexo 从 github 克隆到本地的主题库无法上传到自己仓库的 thems 文件夹</a><time datetime="2025-11-06T07:46:24.000Z" title="发表于 2025-11-06 15:46:24">2025-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/05/%E4%BF%AE%E6%94%B9Nginx%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99%E7%9A%84%E9%A1%B5%E9%9D%A2/" title="修改 Nginx 部署网站的页面">修改 Nginx 部署网站的页面</a><time datetime="2025-11-05T11:52:40.000Z" title="发表于 2025-11-05 19:52:40">2025-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/03/%E9%99%88%E6%83%85%E8%A1%A8-%E6%9D%8E%E5%AF%86/" title="陈情表 -- 李密">陈情表 -- 李密</a><time datetime="2025-11-03T01:09:15.000Z" title="发表于 2025-11-03 09:09:15">2025-11-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/28/%E6%AE%B5%E4%BD%8D/" title="段位">段位</a><time datetime="2025-10-28T08:46:09.000Z" title="发表于 2025-10-28 16:46:09">2025-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 市井一俗人</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>